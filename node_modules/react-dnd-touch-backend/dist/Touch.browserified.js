(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.reactDndTouchBackend = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

'use strict';

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function(condition, format, a, b, c, d, e, f) {
  if (process.env.NODE_ENV !== 'production') {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;

}).call(this,require('_process'))

},{"_process":2}],2:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],3:[function(require,module,exports){
/**
 * Copyright 2015, Yahoo Inc.
 * Copyrights licensed under the MIT License. See the accompanying LICENSE file for terms.
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TouchBackend = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.default = createTouchBackend;

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function getEventClientTouchOffset(e) {
    if (e.targetTouches.length === 1) {
        return getEventClientOffset(e.targetTouches[0]);
    }
}

function getEventClientOffset(e) {
    if (e.targetTouches) {
        return getEventClientTouchOffset(e);
    } else {
        return {
            x: e.clientX,
            y: e.clientY
        };
    }
}

// Polyfill for document.elementsFromPoint
var elementsFromPoint = (typeof document !== 'undefined' && document.elementsFromPoint || function (x, y) {

    if (document.msElementsFromPoint) {
        // msElementsFromPoint is much faster but returns a node-list, so convert it to an array
        return Array.prototype.slice.call(document.msElementsFromPoint(x, y), 0);
    }

    var elements = [],
        previousPointerEvents = [],
        current,
        i,
        d;

    // get all elements via elementFromPoint, and remove them from hit-testing in order
    while ((current = document.elementFromPoint(x, y)) && elements.indexOf(current) === -1 && current !== null) {

        // push the element and its current style
        elements.push(current);
        previousPointerEvents.push({
            value: current.style.getPropertyValue('pointer-events'),
            priority: current.style.getPropertyPriority('pointer-events')
        });

        // add "pointer-events: none", to get to the underlying element
        current.style.setProperty('pointer-events', 'none', 'important');
    }

    // restore the previous pointer-events values
    for (i = previousPointerEvents.length; d = previousPointerEvents[--i];) {
        elements[i].style.setProperty('pointer-events', d.value ? d.value : '', d.priority);
    }

    // return our results
    return elements;
}).bind(typeof document !== 'undefined' ? document : null);

var supportsPassive = function () {
    // simular to jQuery's test
    var supported = false;
    try {
        addEventListener('test', null, Object.defineProperty({}, 'passive', {
            get: function get() {
                supported = true;
            }
        }));
    } catch (e) {}
    return supported;
}();

var ELEMENT_NODE = 1;
function getNodeClientOffset(node) {
    var el = node.nodeType === ELEMENT_NODE ? node : node.parentElement;

    if (!el) {
        return null;
    }

    var _el$getBoundingClient = el.getBoundingClientRect(),
        top = _el$getBoundingClient.top,
        left = _el$getBoundingClient.left;

    return { x: left, y: top };
}

var eventNames = {
    mouse: {
        start: 'mousedown',
        move: 'mousemove',
        end: 'mouseup',
        contextmenu: 'contextmenu'
    },
    touch: {
        start: 'touchstart',
        move: 'touchmove',
        end: 'touchend'
    },
    keyboard: {
        keydown: 'keydown'
    }
};

var TouchBackend = exports.TouchBackend = function () {
    function TouchBackend(manager) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        _classCallCheck(this, TouchBackend);

        options.delayTouchStart = options.delayTouchStart || options.delay;

        options = _extends({
            enableTouchEvents: true,
            enableMouseEvents: false,
            enableKeyboardEvents: false,
            delayTouchStart: 0,
            delayMouseStart: 0
        }, options);

        this.actions = manager.getActions();
        this.monitor = manager.getMonitor();
        this.registry = manager.getRegistry();

        this.enableKeyboardEvents = options.enableKeyboardEvents;
        this.enableMouseEvents = options.enableMouseEvents;
        this.delayTouchStart = options.delayTouchStart;
        this.delayMouseStart = options.delayMouseStart;
        this.sourceNodes = {};
        this.sourceNodeOptions = {};
        this.sourcePreviewNodes = {};
        this.sourcePreviewNodeOptions = {};
        this.targetNodes = {};
        this.targetNodeOptions = {};
        this.listenerTypes = [];
        this._mouseClientOffset = {};

        if (options.enableMouseEvents) {
            this.listenerTypes.push('mouse');
        }

        if (options.enableTouchEvents) {
            this.listenerTypes.push('touch');
        }

        if (options.enableKeyboardEvents) {
            this.listenerTypes.push('keyboard');
        }

        this.getSourceClientOffset = this.getSourceClientOffset.bind(this);
        this.handleTopMoveStart = this.handleTopMoveStart.bind(this);
        this.handleTopMoveStartDelay = this.handleTopMoveStartDelay.bind(this);
        this.handleTopMoveStartCapture = this.handleTopMoveStartCapture.bind(this);
        this.handleTopMoveCapture = this.handleTopMoveCapture.bind(this);
        this.handleTopMove = this.handleTopMove.bind(this);
        this.handleTopMoveEndCapture = this.handleTopMoveEndCapture.bind(this);
        this.handleCancelOnEscape = this.handleCancelOnEscape.bind(this);
    }

    _createClass(TouchBackend, [{
        key: 'setup',
        value: function setup() {
            if (typeof window === 'undefined') {
                return;
            }

            (0, _invariant2.default)(!this.constructor.isSetUp, 'Cannot have two Touch backends at the same time.');
            this.constructor.isSetUp = true;

            this.addEventListener(window, 'start', this.getTopMoveStartHandler());
            this.addEventListener(window, 'start', this.handleTopMoveStartCapture, true);
            this.addEventListener(window, 'move', this.handleTopMove);
            this.addEventListener(window, 'move', this.handleTopMoveCapture, true);
            this.addEventListener(window, 'end', this.handleTopMoveEndCapture, true);

            if (this.enableMouseEvents) {
                this.addEventListener(window, 'contextmenu', this.handleTopMoveEndCapture);
            }

            if (this.enableKeyboardEvents) {
                this.addEventListener(window, 'keydown', this.handleCancelOnEscape, true);
            }
        }
    }, {
        key: 'teardown',
        value: function teardown() {
            if (typeof window === 'undefined') {
                return;
            }

            this.constructor.isSetUp = false;
            this._mouseClientOffset = {};

            this.removeEventListener(window, 'start', this.handleTopMoveStartCapture, true);
            this.removeEventListener(window, 'start', this.handleTopMoveStart);
            this.removeEventListener(window, 'move', this.handleTopMoveCapture, true);
            this.removeEventListener(window, 'move', this.handleTopMove);
            this.removeEventListener(window, 'end', this.handleTopMoveEndCapture, true);

            if (this.enableMouseEvents) {
                this.removeEventListener(window, 'contextmenu', this.handleTopMoveEndCapture);
            }

            if (this.enableKeyboardEvents) {
                this.removeEventListener(window, 'keydown', this.handleCancelOnEscape, true);
            }

            this.uninstallSourceNodeRemovalObserver();
        }
    }, {
        key: 'addEventListener',
        value: function addEventListener(subject, event, handler, capture) {
            var options = supportsPassive ? { capture: capture, passive: false } : capture;

            this.listenerTypes.forEach(function (listenerType) {
                subject.addEventListener(eventNames[listenerType][event], handler, options);
            });
        }
    }, {
        key: 'removeEventListener',
        value: function removeEventListener(subject, event, handler, capture) {
            var options = supportsPassive ? { capture: capture, passive: false } : capture;

            this.listenerTypes.forEach(function (listenerType) {
                subject.removeEventListener(eventNames[listenerType][event], handler, options);
            });
        }
    }, {
        key: 'connectDragSource',
        value: function connectDragSource(sourceId, node, options) {
            var _this = this;

            var handleMoveStart = this.handleMoveStart.bind(this, sourceId);
            this.sourceNodes[sourceId] = node;

            this.addEventListener(node, 'start', handleMoveStart);

            return function () {
                delete _this.sourceNodes[sourceId];
                _this.removeEventListener(node, 'start', handleMoveStart);
            };
        }
    }, {
        key: 'connectDragPreview',
        value: function connectDragPreview(sourceId, node, options) {
            var _this2 = this;

            this.sourcePreviewNodeOptions[sourceId] = options;
            this.sourcePreviewNodes[sourceId] = node;

            return function () {
                delete _this2.sourcePreviewNodes[sourceId];
                delete _this2.sourcePreviewNodeOptions[sourceId];
            };
        }
    }, {
        key: 'connectDropTarget',
        value: function connectDropTarget(targetId, node) {
            var _this3 = this;

            var handleMove = function handleMove(e) {
                var coords = void 0;

                /**
                 * Grab the coordinates for the current mouse/touch position
                 */
                switch (e.type) {
                    case eventNames.mouse.move:
                        coords = { x: e.clientX, y: e.clientY };
                        break;

                    case eventNames.touch.move:
                        coords = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                        break;
                }

                /**
                 * Use the coordinates to grab the element the drag ended on.
                 * If the element is the same as the target node (or any of it's children) then we have hit a drop target and can handle the move.
                 */
                var droppedOn = document.elementFromPoint(coords.x, coords.y);
                var childMatch = node.contains(droppedOn);

                if (droppedOn === node || childMatch) {
                    return _this3.handleMove(e, targetId);
                }
            };

            /**
             * Attaching the event listener to the body so that touchmove will work while dragging over multiple target elements.
             */
            this.addEventListener(document.querySelector('body'), 'move', handleMove);
            this.targetNodes[targetId] = node;

            return function () {
                delete _this3.targetNodes[targetId];
                _this3.removeEventListener(document.querySelector('body'), 'move', handleMove);
            };
        }
    }, {
        key: 'getSourceClientOffset',
        value: function getSourceClientOffset(sourceId) {
            return getNodeClientOffset(this.sourceNodes[sourceId]);
        }
    }, {
        key: 'handleTopMoveStartCapture',
        value: function handleTopMoveStartCapture(e) {
            this.moveStartSourceIds = [];
        }
    }, {
        key: 'handleMoveStart',
        value: function handleMoveStart(sourceId) {
            this.moveStartSourceIds.unshift(sourceId);
        }
    }, {
        key: 'getTopMoveStartHandler',
        value: function getTopMoveStartHandler() {
            if (!this.delayTouchStart && !this.delayMouseStart) {
                return this.handleTopMoveStart;
            }

            return this.handleTopMoveStartDelay;
        }
    }, {
        key: 'handleTopMoveStart',
        value: function handleTopMoveStart(e) {
            // Don't prematurely preventDefault() here since it might:
            // 1. Mess up scrolling
            // 2. Mess up long tap (which brings up context menu)
            // 3. If there's an anchor link as a child, tap won't be triggered on link

            var clientOffset = getEventClientOffset(e);
            if (clientOffset) {
                this._mouseClientOffset = clientOffset;
            }
        }
    }, {
        key: 'handleTopMoveStartDelay',
        value: function handleTopMoveStartDelay(e) {
            var delay = e.type === eventNames.touch.start ? this.delayTouchStart : this.delayMouseStart;
            this.timeout = setTimeout(this.handleTopMoveStart.bind(this, e), delay);
        }
    }, {
        key: 'handleTopMoveCapture',
        value: function handleTopMoveCapture(e) {
            this.dragOverTargetIds = [];
        }
    }, {
        key: 'handleMove',
        value: function handleMove(e, targetId) {
            this.dragOverTargetIds.unshift(targetId);
        }
    }, {
        key: 'handleTopMove',
        value: function handleTopMove(e) {
            var _this4 = this;

            clearTimeout(this.timeout);

            var moveStartSourceIds = this.moveStartSourceIds,
                dragOverTargetIds = this.dragOverTargetIds;

            var clientOffset = getEventClientOffset(e);

            if (!clientOffset) {
                return;
            }

            // If we're not dragging and we've moved a little, that counts as a drag start
            if (!this.monitor.isDragging() && this._mouseClientOffset.hasOwnProperty('x') && moveStartSourceIds && (this._mouseClientOffset.x !== clientOffset.x || this._mouseClientOffset.y !== clientOffset.y)) {
                this.moveStartSourceIds = null;
                this.actions.beginDrag(moveStartSourceIds, {
                    clientOffset: this._mouseClientOffset,
                    getSourceClientOffset: this.getSourceClientOffset,
                    publishSource: false
                });
            }

            if (!this.monitor.isDragging()) {
                return;
            }

            var sourceNode = this.sourceNodes[this.monitor.getSourceId()];
            this.installSourceNodeRemovalObserver(sourceNode);
            this.actions.publishDragSource();

            e.preventDefault();

            // Get the node elements of the hovered DropTargets
            var dragOverTargetNodes = dragOverTargetIds.map(function (key) {
                return _this4.targetNodes[key];
            });
            // Get the a ordered list of nodes that are touched by
            var elementsAtPoint = elementsFromPoint(clientOffset.x, clientOffset.y);
            var orderedDragOverTargetIds = elementsAtPoint
            // Filter off nodes that arent a hovered DropTargets nodes
            .filter(function (node) {
                return dragOverTargetNodes.indexOf(node) > -1;
            })
            // Map back the nodes elements to targetIds
            .map(function (node) {
                for (var targetId in _this4.targetNodes) {
                    if (node === _this4.targetNodes[targetId]) return targetId;
                }
                return null;
            })
            // Filter off possible null rows
            .filter(function (node) {
                return !!node;
            });

            // Reverse order because dnd-core reverse it before calling the DropTarget drop methods
            orderedDragOverTargetIds.reverse();

            this.actions.hover(orderedDragOverTargetIds, {
                clientOffset: clientOffset
            });
        }
    }, {
        key: 'handleTopMoveEndCapture',
        value: function handleTopMoveEndCapture(e) {
            if (!this.monitor.isDragging() || this.monitor.didDrop()) {
                this.moveStartSourceIds = null;
                return;
            }

            e.preventDefault();

            this._mouseClientOffset = {};

            this.uninstallSourceNodeRemovalObserver();
            this.actions.drop();
            this.actions.endDrag();
        }
    }, {
        key: 'handleCancelOnEscape',
        value: function handleCancelOnEscape(e) {
            if (e.key === 'Escape') {
                this._mouseClientOffset = {};

                this.uninstallSourceNodeRemovalObserver();
                this.actions.endDrag();
            }
        }
    }, {
        key: 'handleOnContextMenu',
        value: function handleOnContextMenu() {
            this.moveStartSourceIds = null;
        }
    }, {
        key: 'installSourceNodeRemovalObserver',
        value: function installSourceNodeRemovalObserver(node) {
            var _this5 = this;

            this.uninstallSourceNodeRemovalObserver();

            this.draggedSourceNode = node;
            this.draggedSourceNodeRemovalObserver = new window.MutationObserver(function () {
                if (!node.parentElement) {
                    _this5.resurrectSourceNode();
                    _this5.uninstallSourceNodeRemovalObserver();
                }
            });

            if (!node || !node.parentElement) {
                return;
            }

            this.draggedSourceNodeRemovalObserver.observe(node.parentElement, { childList: true });
        }
    }, {
        key: 'resurrectSourceNode',
        value: function resurrectSourceNode() {
            this.draggedSourceNode.style.display = 'none';
            this.draggedSourceNode.removeAttribute('data-reactid');
            document.body.appendChild(this.draggedSourceNode);
        }
    }, {
        key: 'uninstallSourceNodeRemovalObserver',
        value: function uninstallSourceNodeRemovalObserver() {
            if (this.draggedSourceNodeRemovalObserver) {
                this.draggedSourceNodeRemovalObserver.disconnect();
            }

            this.draggedSourceNodeRemovalObserver = null;
            this.draggedSourceNode = null;
        }
    }]);

    return TouchBackend;
}();

function createTouchBackend() {
    var optionsOrManager = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var touchBackendFactory = function touchBackendFactory(manager) {
        return new TouchBackend(manager, optionsOrManager);
    };

    if (optionsOrManager.getMonitor) {
        return touchBackendFactory(optionsOrManager);
    } else {
        return touchBackendFactory;
    }
}

},{"invariant":1}]},{},[3])(3)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvaW52YXJpYW50L2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwic3JjXFxUb3VjaC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG52YXIgaW52YXJpYW50ID0gZnVuY3Rpb24oY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAnTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArXG4gICAgICAgICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLidcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24oKSB7IHJldHVybiBhcmdzW2FyZ0luZGV4KytdOyB9KVxuICAgICAgKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTUsIFlhaG9vIEluYy5cclxuICogQ29weXJpZ2h0cyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSB0aGUgYWNjb21wYW55aW5nIExJQ0VOU0UgZmlsZSBmb3IgdGVybXMuXHJcbiAqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ2ludmFyaWFudCc7XHJcblxyXG5mdW5jdGlvbiBnZXRFdmVudENsaWVudFRvdWNoT2Zmc2V0IChlKSB7XHJcbiAgICBpZiAoZS50YXJnZXRUb3VjaGVzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgIHJldHVybiBnZXRFdmVudENsaWVudE9mZnNldChlLnRhcmdldFRvdWNoZXNbMF0pO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRFdmVudENsaWVudE9mZnNldCAoZSkge1xyXG4gICAgaWYgKGUudGFyZ2V0VG91Y2hlcykge1xyXG4gICAgICAgIHJldHVybiBnZXRFdmVudENsaWVudFRvdWNoT2Zmc2V0KGUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB4OiBlLmNsaWVudFgsXHJcbiAgICAgICAgICAgIHk6IGUuY2xpZW50WVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbi8vIFBvbHlmaWxsIGZvciBkb2N1bWVudC5lbGVtZW50c0Zyb21Qb2ludFxyXG5jb25zdCBlbGVtZW50c0Zyb21Qb2ludCA9ICgodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5lbGVtZW50c0Zyb21Qb2ludCkgfHwgZnVuY3Rpb24gKHgseSkge1xyXG4gICAgXHJcbiAgICBpZiAoZG9jdW1lbnQubXNFbGVtZW50c0Zyb21Qb2ludCkge1xyXG4gICAgICAgIC8vIG1zRWxlbWVudHNGcm9tUG9pbnQgaXMgbXVjaCBmYXN0ZXIgYnV0IHJldHVybnMgYSBub2RlLWxpc3QsIHNvIGNvbnZlcnQgaXQgdG8gYW4gYXJyYXlcclxuICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZG9jdW1lbnQubXNFbGVtZW50c0Zyb21Qb2ludCh4LCB5KSwgMCk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGVsZW1lbnRzID0gW10sIHByZXZpb3VzUG9pbnRlckV2ZW50cyA9IFtdLCBjdXJyZW50LCBpLCBkO1xyXG5cclxuICAgIC8vIGdldCBhbGwgZWxlbWVudHMgdmlhIGVsZW1lbnRGcm9tUG9pbnQsIGFuZCByZW1vdmUgdGhlbSBmcm9tIGhpdC10ZXN0aW5nIGluIG9yZGVyXHJcbiAgICB3aGlsZSAoKGN1cnJlbnQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHgseSkpICYmIGVsZW1lbnRzLmluZGV4T2YoY3VycmVudCkgPT09IC0xICYmIGN1cnJlbnQgIT09IG51bGwpIHtcclxuXHJcbiAgICAgIC8vIHB1c2ggdGhlIGVsZW1lbnQgYW5kIGl0cyBjdXJyZW50IHN0eWxlXHJcbiAgICBcdGVsZW1lbnRzLnB1c2goY3VycmVudCk7XHJcbiAgICBcdHByZXZpb3VzUG9pbnRlckV2ZW50cy5wdXNoKHtcclxuICAgICAgICAgIHZhbHVlOiBjdXJyZW50LnN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ3BvaW50ZXItZXZlbnRzJyksXHJcbiAgICAgICAgICBwcmlvcml0eTogY3VycmVudC5zdHlsZS5nZXRQcm9wZXJ0eVByaW9yaXR5KCdwb2ludGVyLWV2ZW50cycpXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gYWRkIFwicG9pbnRlci1ldmVudHM6IG5vbmVcIiwgdG8gZ2V0IHRvIHRoZSB1bmRlcmx5aW5nIGVsZW1lbnRcclxuICAgIFx0Y3VycmVudC5zdHlsZS5zZXRQcm9wZXJ0eSgncG9pbnRlci1ldmVudHMnLCAnbm9uZScsICdpbXBvcnRhbnQnKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyByZXN0b3JlIHRoZSBwcmV2aW91cyBwb2ludGVyLWV2ZW50cyB2YWx1ZXNcclxuICAgIGZvcihpID0gcHJldmlvdXNQb2ludGVyRXZlbnRzLmxlbmd0aDsgZD1wcmV2aW91c1BvaW50ZXJFdmVudHNbLS1pXTsgKSB7XHJcbiAgICBcdGVsZW1lbnRzW2ldLnN0eWxlLnNldFByb3BlcnR5KCdwb2ludGVyLWV2ZW50cycsIGQudmFsdWUgPyBkLnZhbHVlOiAnJywgZC5wcmlvcml0eSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcmV0dXJuIG91ciByZXN1bHRzXHJcbiAgICByZXR1cm4gZWxlbWVudHM7XHJcblxyXG59KS5iaW5kKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBkb2N1bWVudCA6IG51bGwpO1xyXG5cclxuY29uc3Qgc3VwcG9ydHNQYXNzaXZlID0gKCgpID0+IHtcclxuICAgIC8vIHNpbXVsYXIgdG8galF1ZXJ5J3MgdGVzdFxyXG4gICAgbGV0IHN1cHBvcnRlZCA9IGZhbHNlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBhZGRFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtnZXQgKCkgeyBzdXBwb3J0ZWQgPSB0cnVlOyB9fSkpO1xyXG4gICAgfSBjYXRjaCAoZSkge31cclxuICAgIHJldHVybiBzdXBwb3J0ZWQ7XHJcbn0pKCk7XHJcblxyXG5cclxuY29uc3QgRUxFTUVOVF9OT0RFID0gMTtcclxuZnVuY3Rpb24gZ2V0Tm9kZUNsaWVudE9mZnNldCAobm9kZSkge1xyXG4gICAgY29uc3QgZWwgPSBub2RlLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREVcclxuICAgICAgICA/IG5vZGVcclxuICAgICAgICA6IG5vZGUucGFyZW50RWxlbWVudDtcclxuXHJcbiAgICBpZiAoIWVsKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgeyB0b3AsIGxlZnQgfSA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgcmV0dXJuIHsgeDogbGVmdCwgeTogdG9wIH07XHJcbn1cclxuXHJcbmNvbnN0IGV2ZW50TmFtZXMgPSB7XHJcbiAgICBtb3VzZToge1xyXG4gICAgICAgIHN0YXJ0OiAnbW91c2Vkb3duJyxcclxuICAgICAgICBtb3ZlOiAnbW91c2Vtb3ZlJyxcclxuICAgICAgICBlbmQ6ICdtb3VzZXVwJyxcclxuICAgICAgICBjb250ZXh0bWVudTogJ2NvbnRleHRtZW51J1xyXG4gICAgfSxcclxuICAgIHRvdWNoOiB7XHJcbiAgICAgICAgc3RhcnQ6ICd0b3VjaHN0YXJ0JyxcclxuICAgICAgICBtb3ZlOiAndG91Y2htb3ZlJyxcclxuICAgICAgICBlbmQ6ICd0b3VjaGVuZCdcclxuICAgIH0sXHJcbiAgICBrZXlib2FyZDoge1xyXG4gICAgICAgIGtleWRvd246ICdrZXlkb3duJ1xyXG4gICAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNsYXNzIFRvdWNoQmFja2VuZCB7XHJcbiAgICBjb25zdHJ1Y3RvciAobWFuYWdlciwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICAgICAgb3B0aW9ucy5kZWxheVRvdWNoU3RhcnQgPSBvcHRpb25zLmRlbGF5VG91Y2hTdGFydCB8fCBvcHRpb25zLmRlbGF5O1xyXG5cclxuICAgICAgICBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICBlbmFibGVUb3VjaEV2ZW50czogdHJ1ZSxcclxuICAgICAgICAgICAgZW5hYmxlTW91c2VFdmVudHM6IGZhbHNlLFxyXG4gICAgICAgICAgICBlbmFibGVLZXlib2FyZEV2ZW50czogZmFsc2UsXHJcbiAgICAgICAgICAgIGRlbGF5VG91Y2hTdGFydDogMCxcclxuICAgICAgICAgICAgZGVsYXlNb3VzZVN0YXJ0OiAwLFxyXG4gICAgICAgICAgICAuLi5vcHRpb25zXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5hY3Rpb25zID0gbWFuYWdlci5nZXRBY3Rpb25zKCk7XHJcbiAgICAgICAgdGhpcy5tb25pdG9yID0gbWFuYWdlci5nZXRNb25pdG9yKCk7XHJcbiAgICAgICAgdGhpcy5yZWdpc3RyeSA9IG1hbmFnZXIuZ2V0UmVnaXN0cnkoKTtcclxuXHJcbiAgICAgICAgdGhpcy5lbmFibGVLZXlib2FyZEV2ZW50cyA9IG9wdGlvbnMuZW5hYmxlS2V5Ym9hcmRFdmVudHM7XHJcbiAgICAgICAgdGhpcy5lbmFibGVNb3VzZUV2ZW50cyA9IG9wdGlvbnMuZW5hYmxlTW91c2VFdmVudHM7XHJcbiAgICAgICAgdGhpcy5kZWxheVRvdWNoU3RhcnQgPSBvcHRpb25zLmRlbGF5VG91Y2hTdGFydDtcclxuICAgICAgICB0aGlzLmRlbGF5TW91c2VTdGFydCA9IG9wdGlvbnMuZGVsYXlNb3VzZVN0YXJ0O1xyXG4gICAgICAgIHRoaXMuc291cmNlTm9kZXMgPSB7fTtcclxuICAgICAgICB0aGlzLnNvdXJjZU5vZGVPcHRpb25zID0ge307XHJcbiAgICAgICAgdGhpcy5zb3VyY2VQcmV2aWV3Tm9kZXMgPSB7fTtcclxuICAgICAgICB0aGlzLnNvdXJjZVByZXZpZXdOb2RlT3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIHRoaXMudGFyZ2V0Tm9kZXMgPSB7fTtcclxuICAgICAgICB0aGlzLnRhcmdldE5vZGVPcHRpb25zID0ge307XHJcbiAgICAgICAgdGhpcy5saXN0ZW5lclR5cGVzID0gW107XHJcbiAgICAgICAgdGhpcy5fbW91c2VDbGllbnRPZmZzZXQgPSB7fTtcclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMuZW5hYmxlTW91c2VFdmVudHMpIHtcclxuICAgICAgICAgICAgdGhpcy5saXN0ZW5lclR5cGVzLnB1c2goJ21vdXNlJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy5lbmFibGVUb3VjaEV2ZW50cykge1xyXG4gICAgICAgICAgICB0aGlzLmxpc3RlbmVyVHlwZXMucHVzaCgndG91Y2gnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLmVuYWJsZUtleWJvYXJkRXZlbnRzKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJUeXBlcy5wdXNoKCdrZXlib2FyZCcpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmdldFNvdXJjZUNsaWVudE9mZnNldCA9IHRoaXMuZ2V0U291cmNlQ2xpZW50T2Zmc2V0LmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVUb3BNb3ZlU3RhcnQgPSB0aGlzLmhhbmRsZVRvcE1vdmVTdGFydC5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuaGFuZGxlVG9wTW92ZVN0YXJ0RGVsYXkgPSB0aGlzLmhhbmRsZVRvcE1vdmVTdGFydERlbGF5LmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVUb3BNb3ZlU3RhcnRDYXB0dXJlID0gdGhpcy5oYW5kbGVUb3BNb3ZlU3RhcnRDYXB0dXJlLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVUb3BNb3ZlQ2FwdHVyZSA9IHRoaXMuaGFuZGxlVG9wTW92ZUNhcHR1cmUuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLmhhbmRsZVRvcE1vdmUgPSB0aGlzLmhhbmRsZVRvcE1vdmUuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLmhhbmRsZVRvcE1vdmVFbmRDYXB0dXJlID0gdGhpcy5oYW5kbGVUb3BNb3ZlRW5kQ2FwdHVyZS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuaGFuZGxlQ2FuY2VsT25Fc2NhcGUgPSB0aGlzLmhhbmRsZUNhbmNlbE9uRXNjYXBlLmJpbmQodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0dXAgKCkge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnZhcmlhbnQoIXRoaXMuY29uc3RydWN0b3IuaXNTZXRVcCwgJ0Nhbm5vdCBoYXZlIHR3byBUb3VjaCBiYWNrZW5kcyBhdCB0aGUgc2FtZSB0aW1lLicpO1xyXG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IuaXNTZXRVcCA9IHRydWU7XHJcblxyXG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih3aW5kb3csICdzdGFydCcsICAgICAgdGhpcy5nZXRUb3BNb3ZlU3RhcnRIYW5kbGVyKCkpO1xyXG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih3aW5kb3csICdzdGFydCcsICAgICAgdGhpcy5oYW5kbGVUb3BNb3ZlU3RhcnRDYXB0dXJlLCB0cnVlKTtcclxuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIod2luZG93LCAnbW92ZScsICAgICAgIHRoaXMuaGFuZGxlVG9wTW92ZSk7XHJcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKHdpbmRvdywgJ21vdmUnLCAgICAgICB0aGlzLmhhbmRsZVRvcE1vdmVDYXB0dXJlLCB0cnVlKTtcclxuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIod2luZG93LCAnZW5kJywgICAgICAgIHRoaXMuaGFuZGxlVG9wTW92ZUVuZENhcHR1cmUsIHRydWUpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5lbmFibGVNb3VzZUV2ZW50cykge1xyXG4gICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIod2luZG93LCAnY29udGV4dG1lbnUnLCB0aGlzLmhhbmRsZVRvcE1vdmVFbmRDYXB0dXJlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmVuYWJsZUtleWJvYXJkRXZlbnRzKXtcclxuICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKHdpbmRvdywgJ2tleWRvd24nLCB0aGlzLmhhbmRsZUNhbmNlbE9uRXNjYXBlLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGVhcmRvd24gKCkge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLmlzU2V0VXAgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9tb3VzZUNsaWVudE9mZnNldCA9IHt9O1xyXG5cclxuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIod2luZG93LCAnc3RhcnQnLCB0aGlzLmhhbmRsZVRvcE1vdmVTdGFydENhcHR1cmUsIHRydWUpO1xyXG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcih3aW5kb3csICdzdGFydCcsIHRoaXMuaGFuZGxlVG9wTW92ZVN0YXJ0KTtcclxuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIod2luZG93LCAnbW92ZScsICB0aGlzLmhhbmRsZVRvcE1vdmVDYXB0dXJlLCB0cnVlKTtcclxuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIod2luZG93LCAnbW92ZScsICB0aGlzLmhhbmRsZVRvcE1vdmUpO1xyXG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcih3aW5kb3csICdlbmQnLCAgIHRoaXMuaGFuZGxlVG9wTW92ZUVuZENhcHR1cmUsIHRydWUpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5lbmFibGVNb3VzZUV2ZW50cykge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIod2luZG93LCAnY29udGV4dG1lbnUnLCB0aGlzLmhhbmRsZVRvcE1vdmVFbmRDYXB0dXJlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmVuYWJsZUtleWJvYXJkRXZlbnRzKXtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKHdpbmRvdywgJ2tleWRvd24nLCB0aGlzLmhhbmRsZUNhbmNlbE9uRXNjYXBlLCB0cnVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMudW5pbnN0YWxsU291cmNlTm9kZVJlbW92YWxPYnNlcnZlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIGFkZEV2ZW50TGlzdGVuZXIgKHN1YmplY3QsIGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlKSB7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHN1cHBvcnRzUGFzc2l2ZSA/IHtjYXB0dXJlLCBwYXNzaXZlOiBmYWxzZX0gOiBjYXB0dXJlO1xyXG5cclxuICAgICAgICB0aGlzLmxpc3RlbmVyVHlwZXMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXJUeXBlKSB7XHJcbiAgICAgICAgICAgIHN1YmplY3QuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWVzW2xpc3RlbmVyVHlwZV1bZXZlbnRdLCBoYW5kbGVyLCBvcHRpb25zKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZW1vdmVFdmVudExpc3RlbmVyIChzdWJqZWN0LCBldmVudCwgaGFuZGxlciwgY2FwdHVyZSkge1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBzdXBwb3J0c1Bhc3NpdmUgPyB7Y2FwdHVyZSwgcGFzc2l2ZTogZmFsc2V9IDogY2FwdHVyZTtcclxuXHJcbiAgICAgICAgdGhpcy5saXN0ZW5lclR5cGVzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyVHlwZSkge1xyXG4gICAgICAgICAgICBzdWJqZWN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lc1tsaXN0ZW5lclR5cGVdW2V2ZW50XSwgaGFuZGxlciwgb3B0aW9ucyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29ubmVjdERyYWdTb3VyY2UgKHNvdXJjZUlkLCBub2RlLCBvcHRpb25zKSB7XHJcbiAgICAgICAgY29uc3QgaGFuZGxlTW92ZVN0YXJ0ID0gdGhpcy5oYW5kbGVNb3ZlU3RhcnQuYmluZCh0aGlzLCBzb3VyY2VJZCk7XHJcbiAgICAgICAgdGhpcy5zb3VyY2VOb2Rlc1tzb3VyY2VJZF0gPSBub2RlO1xyXG5cclxuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIobm9kZSwgJ3N0YXJ0JywgaGFuZGxlTW92ZVN0YXJ0KTtcclxuXHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuc291cmNlTm9kZXNbc291cmNlSWRdO1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIobm9kZSwgJ3N0YXJ0JywgaGFuZGxlTW92ZVN0YXJ0KTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbm5lY3REcmFnUHJldmlldyAoc291cmNlSWQsIG5vZGUsIG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLnNvdXJjZVByZXZpZXdOb2RlT3B0aW9uc1tzb3VyY2VJZF0gPSBvcHRpb25zO1xyXG4gICAgICAgIHRoaXMuc291cmNlUHJldmlld05vZGVzW3NvdXJjZUlkXSA9IG5vZGU7XHJcblxyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNvdXJjZVByZXZpZXdOb2Rlc1tzb3VyY2VJZF07XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNvdXJjZVByZXZpZXdOb2RlT3B0aW9uc1tzb3VyY2VJZF07XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBjb25uZWN0RHJvcFRhcmdldCAodGFyZ2V0SWQsIG5vZGUpIHtcclxuICAgICAgICBjb25zdCBoYW5kbGVNb3ZlID0gKGUpID0+IHtcclxuICAgICAgICAgICAgbGV0IGNvb3JkcztcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHcmFiIHRoZSBjb29yZGluYXRlcyBmb3IgdGhlIGN1cnJlbnQgbW91c2UvdG91Y2ggcG9zaXRpb25cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHN3aXRjaCAoZS50eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgZXZlbnROYW1lcy5tb3VzZS5tb3ZlOlxyXG4gICAgICAgICAgICAgICAgY29vcmRzID0geyB4OiBlLmNsaWVudFgsIHk6IGUuY2xpZW50WSB9O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIGV2ZW50TmFtZXMudG91Y2gubW92ZTpcclxuICAgICAgICAgICAgICAgIGNvb3JkcyA9IHsgeDogZS50b3VjaGVzWzBdLmNsaWVudFgsIHk6IGUudG91Y2hlc1swXS5jbGllbnRZIH07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFVzZSB0aGUgY29vcmRpbmF0ZXMgdG8gZ3JhYiB0aGUgZWxlbWVudCB0aGUgZHJhZyBlbmRlZCBvbi5cclxuICAgICAgICAgICAgICogSWYgdGhlIGVsZW1lbnQgaXMgdGhlIHNhbWUgYXMgdGhlIHRhcmdldCBub2RlIChvciBhbnkgb2YgaXQncyBjaGlsZHJlbikgdGhlbiB3ZSBoYXZlIGhpdCBhIGRyb3AgdGFyZ2V0IGFuZCBjYW4gaGFuZGxlIHRoZSBtb3ZlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgbGV0IGRyb3BwZWRPbiA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoY29vcmRzLngsIGNvb3Jkcy55KTtcclxuICAgICAgICAgICAgbGV0IGNoaWxkTWF0Y2ggPSBub2RlLmNvbnRhaW5zKGRyb3BwZWRPbik7XHJcblxyXG4gICAgICAgICAgICBpZiAoZHJvcHBlZE9uID09PSBub2RlIHx8IGNoaWxkTWF0Y2gpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZU1vdmUoZSwgdGFyZ2V0SWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQXR0YWNoaW5nIHRoZSBldmVudCBsaXN0ZW5lciB0byB0aGUgYm9keSBzbyB0aGF0IHRvdWNobW92ZSB3aWxsIHdvcmsgd2hpbGUgZHJhZ2dpbmcgb3ZlciBtdWx0aXBsZSB0YXJnZXQgZWxlbWVudHMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2JvZHknKSwgJ21vdmUnLCBoYW5kbGVNb3ZlKTtcclxuICAgICAgICB0aGlzLnRhcmdldE5vZGVzW3RhcmdldElkXSA9IG5vZGU7XHJcblxyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnRhcmdldE5vZGVzW3RhcmdldElkXTtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2JvZHknKSwgJ21vdmUnLCBoYW5kbGVNb3ZlKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGdldFNvdXJjZUNsaWVudE9mZnNldCAoc291cmNlSWQpIHtcclxuICAgICAgICByZXR1cm4gZ2V0Tm9kZUNsaWVudE9mZnNldCh0aGlzLnNvdXJjZU5vZGVzW3NvdXJjZUlkXSk7XHJcbiAgICB9XHJcblxyXG4gICAgaGFuZGxlVG9wTW92ZVN0YXJ0Q2FwdHVyZSAoZSkge1xyXG4gICAgICAgIHRoaXMubW92ZVN0YXJ0U291cmNlSWRzID0gW107XHJcbiAgICB9XHJcblxyXG4gICAgaGFuZGxlTW92ZVN0YXJ0IChzb3VyY2VJZCkge1xyXG4gICAgICAgIHRoaXMubW92ZVN0YXJ0U291cmNlSWRzLnVuc2hpZnQoc291cmNlSWQpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldFRvcE1vdmVTdGFydEhhbmRsZXIgKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5kZWxheVRvdWNoU3RhcnQgJiYgIXRoaXMuZGVsYXlNb3VzZVN0YXJ0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVRvcE1vdmVTdGFydDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVRvcE1vdmVTdGFydERlbGF5O1xyXG4gICAgfVxyXG5cclxuICAgIGhhbmRsZVRvcE1vdmVTdGFydCAoZSkge1xyXG4gICAgICAgIC8vIERvbid0IHByZW1hdHVyZWx5IHByZXZlbnREZWZhdWx0KCkgaGVyZSBzaW5jZSBpdCBtaWdodDpcclxuICAgICAgICAvLyAxLiBNZXNzIHVwIHNjcm9sbGluZ1xyXG4gICAgICAgIC8vIDIuIE1lc3MgdXAgbG9uZyB0YXAgKHdoaWNoIGJyaW5ncyB1cCBjb250ZXh0IG1lbnUpXHJcbiAgICAgICAgLy8gMy4gSWYgdGhlcmUncyBhbiBhbmNob3IgbGluayBhcyBhIGNoaWxkLCB0YXAgd29uJ3QgYmUgdHJpZ2dlcmVkIG9uIGxpbmtcclxuXHJcbiAgICAgICAgY29uc3QgY2xpZW50T2Zmc2V0ID0gZ2V0RXZlbnRDbGllbnRPZmZzZXQoZSk7XHJcbiAgICAgICAgaWYgKGNsaWVudE9mZnNldCkge1xyXG4gICAgICAgICAgICB0aGlzLl9tb3VzZUNsaWVudE9mZnNldCA9IGNsaWVudE9mZnNldDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaGFuZGxlVG9wTW92ZVN0YXJ0RGVsYXkgKGUpIHtcclxuICAgICAgICBjb25zdCBkZWxheSA9IChlLnR5cGUgPT09IGV2ZW50TmFtZXMudG91Y2guc3RhcnQpXHJcbiAgICAgICAgICAgID8gdGhpcy5kZWxheVRvdWNoU3RhcnRcclxuICAgICAgICAgICAgOiB0aGlzLmRlbGF5TW91c2VTdGFydDtcclxuICAgICAgICB0aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXMuaGFuZGxlVG9wTW92ZVN0YXJ0LmJpbmQodGhpcywgZSksIGRlbGF5KTtcclxuICAgIH1cclxuXHJcbiAgICBoYW5kbGVUb3BNb3ZlQ2FwdHVyZSAoZSkge1xyXG4gICAgICAgIHRoaXMuZHJhZ092ZXJUYXJnZXRJZHMgPSBbXTtcclxuICAgIH1cclxuXHJcbiAgICBoYW5kbGVNb3ZlKCBlLCB0YXJnZXRJZCApIHtcclxuICAgICAgICB0aGlzLmRyYWdPdmVyVGFyZ2V0SWRzLnVuc2hpZnQoIHRhcmdldElkICk7XHJcbiAgICB9XHJcblxyXG4gICAgaGFuZGxlVG9wTW92ZSAoZSkge1xyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpO1xyXG5cclxuICAgICAgICBjb25zdCB7IG1vdmVTdGFydFNvdXJjZUlkcywgZHJhZ092ZXJUYXJnZXRJZHMgfSA9IHRoaXM7XHJcbiAgICAgICAgY29uc3QgY2xpZW50T2Zmc2V0ID0gZ2V0RXZlbnRDbGllbnRPZmZzZXQoZSk7XHJcblxyXG4gICAgICAgIGlmICghY2xpZW50T2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvLyBJZiB3ZSdyZSBub3QgZHJhZ2dpbmcgYW5kIHdlJ3ZlIG1vdmVkIGEgbGl0dGxlLCB0aGF0IGNvdW50cyBhcyBhIGRyYWcgc3RhcnRcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICF0aGlzLm1vbml0b3IuaXNEcmFnZ2luZygpICYmXHJcbiAgICAgICAgICAgIHRoaXMuX21vdXNlQ2xpZW50T2Zmc2V0Lmhhc093blByb3BlcnR5KCd4JykgJiZcclxuICAgICAgICAgICAgbW92ZVN0YXJ0U291cmNlSWRzICYmXHJcbiAgICAgICAgICAgIChcclxuICAgICAgICAgICAgICAgIHRoaXMuX21vdXNlQ2xpZW50T2Zmc2V0LnggIT09IGNsaWVudE9mZnNldC54IHx8XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tb3VzZUNsaWVudE9mZnNldC55ICE9PSBjbGllbnRPZmZzZXQueVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIHRoaXMubW92ZVN0YXJ0U291cmNlSWRzID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5hY3Rpb25zLmJlZ2luRHJhZyhtb3ZlU3RhcnRTb3VyY2VJZHMsIHtcclxuICAgICAgICAgICAgICAgIGNsaWVudE9mZnNldDogdGhpcy5fbW91c2VDbGllbnRPZmZzZXQsXHJcbiAgICAgICAgICAgICAgICBnZXRTb3VyY2VDbGllbnRPZmZzZXQ6IHRoaXMuZ2V0U291cmNlQ2xpZW50T2Zmc2V0LFxyXG4gICAgICAgICAgICAgICAgcHVibGlzaFNvdXJjZTogZmFsc2VcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXRoaXMubW9uaXRvci5pc0RyYWdnaW5nKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3Qgc291cmNlTm9kZSA9IHRoaXMuc291cmNlTm9kZXNbdGhpcy5tb25pdG9yLmdldFNvdXJjZUlkKCldO1xyXG4gICAgICAgIHRoaXMuaW5zdGFsbFNvdXJjZU5vZGVSZW1vdmFsT2JzZXJ2ZXIoc291cmNlTm9kZSk7XHJcbiAgICAgICAgdGhpcy5hY3Rpb25zLnB1Ymxpc2hEcmFnU291cmNlKCk7XHJcblxyXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgLy8gR2V0IHRoZSBub2RlIGVsZW1lbnRzIG9mIHRoZSBob3ZlcmVkIERyb3BUYXJnZXRzXHJcbiAgICAgICAgY29uc3QgZHJhZ092ZXJUYXJnZXROb2RlcyA9IGRyYWdPdmVyVGFyZ2V0SWRzLm1hcChrZXkgPT4gdGhpcy50YXJnZXROb2Rlc1trZXldKTtcclxuICAgICAgICAvLyBHZXQgdGhlIGEgb3JkZXJlZCBsaXN0IG9mIG5vZGVzIHRoYXQgYXJlIHRvdWNoZWQgYnlcclxuICAgICAgICBsZXQgZWxlbWVudHNBdFBvaW50ID0gZWxlbWVudHNGcm9tUG9pbnQoY2xpZW50T2Zmc2V0LngsIGNsaWVudE9mZnNldC55KTtcclxuICAgICAgICBsZXQgb3JkZXJlZERyYWdPdmVyVGFyZ2V0SWRzID0gZWxlbWVudHNBdFBvaW50XHJcbiAgICAgICAgICAvLyBGaWx0ZXIgb2ZmIG5vZGVzIHRoYXQgYXJlbnQgYSBob3ZlcmVkIERyb3BUYXJnZXRzIG5vZGVzXHJcbiAgICAgICAgICAuZmlsdGVyKG5vZGUgPT4gZHJhZ092ZXJUYXJnZXROb2Rlcy5pbmRleE9mKG5vZGUpID4gLTEpXHJcbiAgICAgICAgICAvLyBNYXAgYmFjayB0aGUgbm9kZXMgZWxlbWVudHMgdG8gdGFyZ2V0SWRzXHJcbiAgICAgICAgICAubWFwKG5vZGUgPT4ge1xyXG4gICAgICAgICAgICBmb3IgKGxldCB0YXJnZXRJZCBpbiB0aGlzLnRhcmdldE5vZGVzKSB7XHJcbiAgICAgICAgICAgICAgaWYgKG5vZGUgPT09IHRoaXMudGFyZ2V0Tm9kZXNbdGFyZ2V0SWRdKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldElkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgfSlcclxuICAgICAgICAgIC8vIEZpbHRlciBvZmYgcG9zc2libGUgbnVsbCByb3dzXHJcbiAgICAgICAgICAuZmlsdGVyKG5vZGUgPT4gISFub2RlKTtcclxuXHJcbiAgICAgICAgLy8gUmV2ZXJzZSBvcmRlciBiZWNhdXNlIGRuZC1jb3JlIHJldmVyc2UgaXQgYmVmb3JlIGNhbGxpbmcgdGhlIERyb3BUYXJnZXQgZHJvcCBtZXRob2RzXHJcbiAgICAgICAgb3JkZXJlZERyYWdPdmVyVGFyZ2V0SWRzLnJldmVyc2UoKTtcclxuXHJcbiAgICAgICAgdGhpcy5hY3Rpb25zLmhvdmVyKG9yZGVyZWREcmFnT3ZlclRhcmdldElkcywge1xyXG4gICAgICAgICAgICBjbGllbnRPZmZzZXQ6IGNsaWVudE9mZnNldFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGhhbmRsZVRvcE1vdmVFbmRDYXB0dXJlIChlKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLm1vbml0b3IuaXNEcmFnZ2luZygpIHx8IHRoaXMubW9uaXRvci5kaWREcm9wKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5tb3ZlU3RhcnRTb3VyY2VJZHMgPSBudWxsO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgIHRoaXMuX21vdXNlQ2xpZW50T2Zmc2V0ID0ge307XHJcblxyXG4gICAgICAgIHRoaXMudW5pbnN0YWxsU291cmNlTm9kZVJlbW92YWxPYnNlcnZlcigpO1xyXG4gICAgICAgIHRoaXMuYWN0aW9ucy5kcm9wKCk7XHJcbiAgICAgICAgdGhpcy5hY3Rpb25zLmVuZERyYWcoKTtcclxuICAgIH1cclxuXHJcbiAgICBoYW5kbGVDYW5jZWxPbkVzY2FwZSAoZSkge1xyXG4gICAgICAgIGlmIChlLmtleSA9PT0gJ0VzY2FwZScpe1xyXG4gICAgICAgICAgICB0aGlzLl9tb3VzZUNsaWVudE9mZnNldCA9IHt9O1xyXG5cclxuICAgICAgICAgICAgdGhpcy51bmluc3RhbGxTb3VyY2VOb2RlUmVtb3ZhbE9ic2VydmVyKCk7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5lbmREcmFnKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGhhbmRsZU9uQ29udGV4dE1lbnUgKCkge1xyXG4gICAgICAgIHRoaXMubW92ZVN0YXJ0U291cmNlSWRzID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBpbnN0YWxsU291cmNlTm9kZVJlbW92YWxPYnNlcnZlciAobm9kZSkge1xyXG4gICAgICAgIHRoaXMudW5pbnN0YWxsU291cmNlTm9kZVJlbW92YWxPYnNlcnZlcigpO1xyXG5cclxuICAgICAgICB0aGlzLmRyYWdnZWRTb3VyY2VOb2RlID0gbm9kZTtcclxuICAgICAgICB0aGlzLmRyYWdnZWRTb3VyY2VOb2RlUmVtb3ZhbE9ic2VydmVyID0gbmV3IHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyKCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKCFub2RlLnBhcmVudEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVzdXJyZWN0U291cmNlTm9kZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy51bmluc3RhbGxTb3VyY2VOb2RlUmVtb3ZhbE9ic2VydmVyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKCFub2RlIHx8ICFub2RlLnBhcmVudEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5kcmFnZ2VkU291cmNlTm9kZVJlbW92YWxPYnNlcnZlci5vYnNlcnZlKFxyXG4gICAgICAgICAgICBub2RlLnBhcmVudEVsZW1lbnQsXHJcbiAgICAgICAgICAgIHsgY2hpbGRMaXN0OiB0cnVlIH1cclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHJlc3VycmVjdFNvdXJjZU5vZGUgKCkge1xyXG4gICAgICAgIHRoaXMuZHJhZ2dlZFNvdXJjZU5vZGUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgICAgICB0aGlzLmRyYWdnZWRTb3VyY2VOb2RlLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1yZWFjdGlkJyk7XHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmRyYWdnZWRTb3VyY2VOb2RlKTtcclxuICAgIH1cclxuXHJcbiAgICB1bmluc3RhbGxTb3VyY2VOb2RlUmVtb3ZhbE9ic2VydmVyICgpIHtcclxuICAgICAgICBpZiAodGhpcy5kcmFnZ2VkU291cmNlTm9kZVJlbW92YWxPYnNlcnZlcikge1xyXG4gICAgICAgICAgICB0aGlzLmRyYWdnZWRTb3VyY2VOb2RlUmVtb3ZhbE9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuZHJhZ2dlZFNvdXJjZU5vZGVSZW1vdmFsT2JzZXJ2ZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZHJhZ2dlZFNvdXJjZU5vZGUgPSBudWxsO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVUb3VjaEJhY2tlbmQgKG9wdGlvbnNPck1hbmFnZXIgPSB7fSkge1xyXG4gICAgY29uc3QgdG91Y2hCYWNrZW5kRmFjdG9yeSA9IGZ1bmN0aW9uIChtYW5hZ2VyKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUb3VjaEJhY2tlbmQobWFuYWdlciwgb3B0aW9uc09yTWFuYWdlcik7XHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChvcHRpb25zT3JNYW5hZ2VyLmdldE1vbml0b3IpIHtcclxuICAgICAgICByZXR1cm4gdG91Y2hCYWNrZW5kRmFjdG9yeShvcHRpb25zT3JNYW5hZ2VyKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHRvdWNoQmFja2VuZEZhY3Rvcnk7XHJcbiAgICB9XHJcbn1cclxuIl19
